Synchronous Programming
    โปรแกรมจะรันทีละบรรทัดจากบนลงล่าง บรรทัดต่อไปจะไม่เริ่มจนกว่าบรรทัดก่อนหน้าจะเสร็จ
EX.
console.log("starting...");
console.log("working#1...");
console.log("ending...");
ผลลัพธ์ :
starting...
working#1...
ending...

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Asynchronous programming
    โปรแกรมจะรันทีละคำสั่ง แต่ถ้าคำสั่งไหนต้องใช้เวลาหรือยังทำงานไม่เสร็จ ก็จะข้ามไปทำคำสั่งถัดไปก่อน
    setTimeout() เป็นฟังก์ชันแบบ asynchronous มันจะ ตั้งเวลาไว้ก่อน แล้วข้ามไปทำบรรทัดถัดไปเลย
EX.
console.log("starting...");
setTimeout(() => console.log("working#2..."), 5000);  
console.log("ending...");
ผลลัพธ์ :
starting...
ending...  // ไม่รอให้ครบ 5 วินาที
working#2...


---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Promise 
    ที่ใช้เก็บสถานะของงานเช่น การโหลดข้อมูลจาก server, การอ่านไฟล์ และจะส่งผลลัพธ์กลับมาในอนาคต เป็นการให้ค่าผลลัพธ์ที่อาจจะ สำเร็จ (resolve) หรือ ล้มเหลว (reject) ก็ได้

// ตัวอย่างการไม่จัดการกับ promise ที่จะสร้างปัญหาให้กับโปรแกรม
function doSomething(hasResource) {
  return new Promise((resolve, reject) => {
    setTimeout(() => (hasResource ? resolve("done") : reject("fail")), 5000);
  });
}
console.log("starting...");
const workStatus = doSomething(false);
console.log(workStatus);
console.log("ending...");

doSomething() คืนค่าเป็น Promise ทันที แต่ผลลัพธ์จริง (done หรือ fail) จะออกหลัง 5 วินาทีดังนั้นตอนที่ console.log(workStatus) ถูกเรียก มันยัง "pending" อยู่
ผลลัพธ์ :
starting...
Promise { <pending> }
ending...
fail   // หลังจาก 5 วิ จะเกิด error แบบ unhandled rejection

                                ------------------------------------------------------------------------------------------------------
การจัดการ Promise ด้วย .then().catch()
    .then() จะทำงานเมื่อ Promise สำเร็จ (resolve)
    .catch() จะทำงานเมื่อ Promise ล้มเหลว (reject)
EX.
doSomething(true)
  .then((result) => {
    console.log("working...");
    console.log(`work status = ${result}`);
    console.log("ending...");
  })
  .catch((error) => {
    console.log(error);
  });
ผลลัพธ์ :
กรณี hasResource = true
    starting...
    working...
    work status = done
    ending...

กรณี hasResource = false
    starting...
    fail

                                ------------------------------------------------------------------------------------------------------
การจัดการ Promise ด้วย async / await 
    คำว่า async บอกว่าฟังก์ชันนี้จะ “คืนค่าเป็น Promise”
    await ใช้เพื่อ “รอผลลัพธ์” ของ Promise ก่อนจะไปบรรทัดต่อไป
    try...catch ใช้จับ error จากการ reject
EX.
async function working2() {
  console.log("starting...");
  try {
    const workStatus = await doSomething(true);
    console.log(workStatus);
    console.log("ending...");
  } catch (error) {
    console.log(error);
  }
}
working2();
ผลลัพธ์ :
กรณี hasResource = true
    starting...
    done
    ending...

กรณี hasResource = false
    starting...
    fail

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

fetch() in JavaScript

    fetch() เป็นฟังก์ชันมาตรฐานของ JS ใช้สำหรับติดต่อกับ backend หรือ API เช่น REST API เพื่อ (GET,POST,PUT,DELETE) ใช้ดึงหรือส่งข้อมูลผ่าน HTTP
    fetch() จะไม่ reject แม้ HTTP status จะเป็น 404 หรือ 500 ต้องตรวจสอบด้วย response.ok เอง

Basic Syntax :
fetch(url, options)
  .then(response => response.json())  // แปลง response เป็น JSON object
  .then(data => console.log(data))
  .catch(error => console.error(error))

url คือ URL ของ API เช่น "https://api.example.com/users"
options คือการกำหนด method, headers, body ฯลฯ (optional)
fetch() จะคืนค่าเป็น Promise
*ถ้า server ตอบกลับเป็น non-JSON, response.json() จะ throw error → ควรใช้ try/catch หรือ .catch()*

EX. GET request :
fetch("https://jsonplaceholder.typicode.com/users")
  .then(response => {
    if (!response.ok) throw new Error("Network error!");
    return response.json();  // แปลง JSON text → JS object
  })
  .then(users => console.log("User list:", users))
  .catch(err => console.error("Error:", err));

fetch → response → ตรวจสอบ response.ok → แปลงเป็น JSON → ใช้งาน

EX. ใช้กับ async/await :
async function loadUsers() {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/users");
    if (!response.ok) throw new Error("Fetch failed!");
    const users = await response.json();
    console.log(users);
  } catch (err) {
    console.error("Error:", err);
  }
}
loadUsers();

await ทำให้รอ Promise เสร็จ → ลดการใช้ .then()

EX. POST request :
async function createUser() {
  const newUser = { name: "Alice", email: "alice@example.com" };

  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/users", {
      method: "POST",                                // ใช้ POST
      headers: { "Content-Type": "application/json" }, // ระบุ JSON
      body: JSON.stringify(newUser),                 // แปลง object → JSON string
    });

    if (!response.ok) throw new Error("POST failed!");
    const result = await response.json();
    console.log("User created:", result);
  } catch (err) {
    console.error("Error:", err);
  }
}
createUser();

if (!response.ok) throw new Error("POST failed!") เพื่อจับ HTTP error จะช่วยให้โค้ด ปลอดภัย และจับ error ได้ครบ

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

เอาไปใช้จริงกับ Project Integrated

import config from "../config/config.js";  
// เอาค่า config จากconfig.js เข้ามาใช้ ที่ทำแบบนี้เพราะถ้าจะเปลี่ยน URL จะได้ไม่ต้องเปลี่ยนหลายที่

document.addEventListener("DOMContentLoaded", () => { 
  fetch("./components/navbar.html")
    .then((res) => res.text())  // แปลง Response body เป็น text (HTML)
    .then((data) => (document.getElementById("navbar").innerHTML = data));

  fetch("./components/footer.html")
    .then((res) => res.text())
    .then((data) => (document.getElementById("footer").innerHTML = data));
});
// ส่วนที่เปลี่ยนการ fetch() navbar.html,footer.html มาใช้ เพราะทำแบบแยก components ไม่รู้ว่าหน้าอื่น จะต้องใช้มั้ยเลยทำเผื่อไว้จะได้ไม่ต้องเขียนบ่อย  
ทำไมถึงใช้การ fetch() เพราะ AI แนะนำให้ใช้ ปกติเคยแยก components แบบใช้เฟรมเวิร์กจะ import เลย

async function loadPlans() {
  try {
// fetch() ข้อมูลจาก API คืนค่า Promise ของ Response 
    const response = await fetch(`${config.API_BASE_URL}/api/v1/study-plans`);
    console.log(response);

// ตรวจสอบ HTTP status
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

// แปลง Response body เป็น JSON
    const data = await response.json();
    console.log("Data from API:", data);
    renderTable(data.data || data); // ถ้า API คืนค่าใน data.data ใช้ได้เลยถ้าไม่ ใช้ data ตรง ๆ

// ถ้า fetch ล้มเหลว, JSON parse ผิด, หรือ HTTP error จะเข้า catch แสดง dialog
  } catch (error) {
    console.error("Error loading study plans:", error);
    showError("There is a problem. Please try again later.");
  }
}

// สร้างตารางใน HTML
function renderTable(data) {
  const tblElement = document.getElementById("planTable");
  tblElement.innerHTML = ""; // ล้างตารางเก่าก่อนใส่ข้อมูลใหม่

  data.forEach((d) => {
    tblElement.innerHTML += `
        <tr class="rowecors">
            <td>${d.id}</td>
            <td>${d.plan_code}</td>
            <td>${d.name_eng}</td>
            <td>${d.name_th}</td>
        </tr>
        `;
  });
}

// แสดง Error Dialog
function showError(message) {
  const logError = document.createElement("dialog");
  logError.className = "ecors-logError";

  const p = document.createElement("p");
  p.className = "ecors-logError-message";
  p.textContent = message;

  logError.appendChild(p);
  document.body.appendChild(logError);
  logError.addEventListener("click", () => logError.close());
  logError.showModal();  // แสดง dialog แบบ modal (บังคับผู้ใช้ต้องปิดก่อนทำอย่างอื่น)
}

window.addEventListener("DOMContentLoaded", loadPlans);  // ฟังก์ชัน loadPlans() จะรันหลัง DOM โหลดเสร็จ ป้องกันปัญหา <div id="planTable"> หายังไม่เจอ


